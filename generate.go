package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of strenum:\n")
	fmt.Fprintf(os.Stderr, "strenum Status active,disabled,paused\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("strenum: ")
	flag.Usage = Usage
	flag.Parse()

	args := flag.Args()
	if len(args) != 2 {
		flag.Usage()
		os.Exit(2)
	}

	path := args[0]
	name := args[1]
	values := strings.Split(args[2], ",")
	dir := filepath.Dir(path)

	result, err := generate("", name, values...)
	if err != nil {

	}

	formatted, err := format.Source(result)

	baseName := fmt.Sprintf("%s_strenum_gen.go", name)
	outputName := filepath.Join(dir, strings.ToLower(baseName))
	err = ioutil.WriteFile(outputName, formatted, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func generate(packageName, name string, values ...string) (result []byte, err error) {
	if len(name) == 0 {
		return nil, fmt.Errorf("Invalid argument name: %s", name)
	}
	if len(values) == 0 {
		return nil, fmt.Errorf("Invalid argument values: %s", strings.Join(values, ","))
	}

	buf := bytes.NewBuffer(make([]byte, 0))

	buf.WriteString(fmt.Sprintf(strings.TrimSpace(`
package %s

// Code generated by \"strenum\"; DO NOT EDIT.
// strenum <dir> %s %s

import "errors"
	`), packageName, name, strings.Join(values, ",")))

	err = generateConstants(buf, name, values...)
	if err != nil {
		return nil, err
	}

	err = generateInterface(buf, name, values...)
	if err != nil {
		return nil, err
	}

	err = generateFuncFromStr(buf, name, values...)
	if err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

var normalizeRegex = regexp.MustCompile("(^[A-Za-z])|_([A-Za-z])")

func toCamelCase(str string) string {
	return normalizeRegex.ReplaceAllStringFunc(str, func(s string) string {
		return strings.ToUpper(strings.Replace(s, "_", "", -1))
	})
}

func capitalized(s string) string {
	return strings.Title(s)
}

func enumValueName(enumName string) func(string) string {
	return func(value string) string {
		return capitalized(enumName) + toCamelCase(value)
	}
}

func enumName(enumName string) string {
	return "Enum" + capitalized(enumName)
}

func privateTypeName(enumName string) string {
	return "private" + capitalized(enumName) + "EnumType"
}

func generateFuncFromStr(output io.Writer, name string, values ...string) error {
	type Data struct {
		Name   string
		Values []string
	}
	t := template.Must(template.New("StrToEnum").Funcs(template.FuncMap{
		"capitalized":   capitalized,
		"enumValueName": enumValueName(name),
		"enumName":      enumName,
	}).Parse(`
		func StrTo{{enumName .Name}}(s string) ({{enumName .Name}}, error) {
			switch s {
			{{- range .Values}}
				case str{{enumValueName .}}: return Enum{{enumValueName .}}, nil
			{{- end}}
			}
			return nil, errors.New("unknown {{enumName .Name}} " + s)
		}
	`))
	err := t.Execute(output, Data{
		Name:   name,
		Values: values,
	})
	return err
}

func generateConstants(output io.Writer, name string, values ...string) error {
	type Data struct {
		Values []string
		Name   string
	}
	t := template.Must(template.New("Constants").Funcs(template.FuncMap{
		"capitalized":     capitalized,
		"enumValueName":   enumValueName(name),
		"privateTypeName": privateTypeName,
	}).Parse(`
		{{$private := privateTypeName .Name}}
		const (
			{{range .Values}}
				str{{enumValueName .}} = "{{.}}"
			{{- end}}

			{{range .Values}}
				Enum{{enumValueName .}} = {{$private}}(str{{enumValueName .}})
			{{- end}}
		)
	`))
	err := t.Execute(output, Data{
		Values: values,
		Name:   name,
	})
	return err
}

func generateInterface(output io.Writer, name string, values ...string) error {
	type Data struct {
		Name   string
		Values []string
	}
	t := template.Must(template.New("Interface").Funcs(template.FuncMap{
		"enumName":        enumName,
		"lower":           strings.ToLower,
		"privateTypeName": privateTypeName,
	}).Parse(`
		{{$public := enumName .Name }}
		{{$private := privateTypeName .Name}}

		type {{$public}} interface {
			{{lower .Name}}()
			String() string
		}
		
		type {{$private}} string
		
		func (s {{$private}}) {{lower .Name}}() {
			// unreachable method
		}
		
		func (s {{$private}}) String() string {
			return string(s)
		}
	`))
	err := t.Execute(output, Data{
		Name:   name,
		Values: values,
	})
	return err
}
