package main

import (
	"bytes"
	"go/format"
	"strings"
	"testing"

	"github.com/sergi/go-diff/diffmatchpatch"
)

func printDiff(expected, actual string) string {
	dmp := diffmatchpatch.New()

	diffs := dmp.DiffMain(expected, actual, false)

	return dmp.DiffPrettyText(diffs)
}

func Test_generateInterface(t *testing.T) {
	buf := bytes.NewBuffer(make([]byte, 0))

	err := generateInterface(buf, "Something", "Aaa", "Bbb", "Ccc")
	if err != nil {
		t.Errorf(err.Error())
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		t.Errorf(err.Error())
	}

	trimmed := strings.TrimSpace(string(formatted))

	expected := strings.TrimSpace(`
		type EnumSomething interface {
			something()
			String() string
		}

		type privateSomethingEnumType string

		func (s privateSomethingEnumType) something() {
			// unreachable method
		}

		func (s privateSomethingEnumType) String() string {
			return string(s)
		}
	`)

	if expected != trimmed {
		t.Errorf("incorrect generated output from generateInterface: \n %s\n", printDiff(expected, trimmed))
	}
}

func Test_generateConstants(t *testing.T) {
	buf := bytes.NewBuffer(make([]byte, 0))

	err := generateConstants(buf, "Something", "Aaa", "Bbb", "Cc_xxxx_zzz")
	if err != nil {
		t.Errorf(err.Error())
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		t.Errorf(err.Error())
	}

	trimmed := strings.TrimSpace(string(formatted))

	expected := strings.TrimSpace(`
         const (
			strSomethingAaa       = "Aaa"
			strSomethingBbb       = "Bbb"
			strSomethingCcXxxxZzz = "Cc_xxxx_zzz"

			EnumSomethingAaa       = privateSomethingEnumType(strSomethingAaa)
			EnumSomethingBbb       = privateSomethingEnumType(strSomethingBbb)
			EnumSomethingCcXxxxZzz = privateSomethingEnumType(strSomethingCcXxxxZzz)
		)
	`)

	if expected != trimmed {
		t.Errorf("incorrect generated output from generateConstants: \n %s\n", printDiff(expected, trimmed))
	}
}

func Test_generateFuncFromStr(t *testing.T) {
	buf := bytes.NewBuffer(make([]byte, 0))

	err := generateFuncFromStr(buf, "Something", "Aaa", "Bbb", "Cc_xxxx_zzz")
	if err != nil {
		t.Errorf(err.Error())
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		t.Errorf(err.Error())
	}

	trimmed := strings.TrimSpace(string(formatted))

	expected := strings.TrimSpace(`
         func StrToEnumSomething(s string) (EnumSomething, error) {
			switch s {
			case strSomethingAaa:
				return EnumSomethingAaa, nil
			case strSomethingBbb:
				return EnumSomethingBbb, nil
			case strSomethingCcXxxxZzz:
				return EnumSomethingCcXxxxZzz, nil
			}
			return nil, errors.New("unknown EnumSomething " + s)
		}
	`)

	if expected != trimmed {
		t.Errorf("incorrect generated output from generateConstants: \n %s\n", printDiff(expected, trimmed))
	}
}

func Test_generate(t *testing.T) {
	bb, err := generate("main", "Something", "Aaa", "Bbb", "Cc_xxxx_zzz")
	if err != nil {
		t.Errorf(err.Error())
	}

	generated := string(bb)

	bb, err = format.Source([]byte(`
package main

// Code generated by \"strenum\"; DO NOT EDIT.
// strenum <dir> Something Aaa,Bbb,Cc_xxxx_zzz

import "errors"

const (
	strSomethingAaa       = "Aaa"
	strSomethingBbb       = "Bbb"
	strSomethingCcXxxxZzz = "Cc_xxxx_zzz"

	EnumSomethingAaa       = privateSomethingEnumType(strSomethingAaa)
	EnumSomethingBbb       = privateSomethingEnumType(strSomethingBbb)
	EnumSomethingCcXxxxZzz = privateSomethingEnumType(strSomethingCcXxxxZzz)
)

type EnumSomething interface {
	something()
	String() string
}

type privateSomethingEnumType string

func (s privateSomethingEnumType) something() {
	// unreachable method
}

func (s privateSomethingEnumType) String() string {
	return string(s)
}

func StrToEnumSomething(s string) (EnumSomething, error) {
	switch s {
	case strSomethingAaa:
		return EnumSomethingAaa, nil
	case strSomethingBbb:
		return EnumSomethingBbb, nil
	case strSomethingCcXxxxZzz:
		return EnumSomethingCcXxxxZzz, nil
	}
	return nil, errors.New("unknown EnumSomething " + s)
}`))

	if err != nil {
		t.Errorf(err.Error())
	}

	expected := string(bb)

	if expected != generated {
		t.Errorf("incorrect generated output from generate: \n %s\n", printDiff(expected, generated))
	}
}

//func Test_1(t *testing.T)  {
//	bb, err := generate("tx", "Status", strings.Split("created pending started completed failed canceled refunded", " ")...)
//	if err != nil {
//		t.Errorf(err.Error())
//	}
//	println(string(bb))
//}
